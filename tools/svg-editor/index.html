<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVGåœ¨çº¿ç¼–è¾‘å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: #2d2d30;
            overflow: hidden;
            height: 100vh;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .header h1 {
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .header-buttons {
            display: flex;
            gap: 10px;
        }
        .header-buttons button {
            padding: 8px 16px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.3s;
        }
        .header-buttons button:hover {
            background: rgba(255,255,255,0.3);
        }
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .toolbar {
            width: 80px;
            background: #252526;
            border-right: 1px solid #1e1e1e;
            display: flex;
            flex-direction: column;
            padding: 10px 5px;
            gap: 5px;
            overflow-y: auto;
        }
        .tool-btn {
            width: 70px;
            height: 70px;
            background: #3e3e42;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #ccc;
            font-size: 11px;
            transition: all 0.3s;
        }
        .tool-btn:hover {
            background: #505053;
            border-color: #667eea;
        }
        .tool-btn.active {
            background: #667eea;
            color: white;
            border-color: #764ba2;
        }
        .tool-btn .icon {
            font-size: 28px;
            margin-bottom: 4px;
        }
        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1e1e1e;
            position: relative;
            overflow: auto;
        }
        #svgCanvas {
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
        }
        .properties-panel {
            width: 280px;
            background: #252526;
            border-left: 1px solid #1e1e1e;
            padding: 15px;
            overflow-y: auto;
            color: #ccc;
        }
        .panel-section {
            margin-bottom: 20px;
        }
        .panel-section h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #fff;
            border-bottom: 1px solid #3e3e42;
            padding-bottom: 8px;
        }
        .property-group {
            margin-bottom: 12px;
        }
        .property-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #aaa;
        }
        .property-group input[type="number"],
        .property-group input[type="text"] {
            width: 100%;
            padding: 6px 8px;
            background: #3e3e42;
            border: 1px solid #555;
            border-radius: 3px;
            color: #ccc;
            font-size: 13px;
        }
        .property-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        .color-input-group {
            display: grid;
            grid-template-columns: 50px 1fr;
            gap: 8px;
            align-items: center;
        }
        .color-input-group input[type="color"] {
            width: 50px;
            height: 35px;
            border: 1px solid #555;
            border-radius: 3px;
            cursor: pointer;
            background: transparent;
        }
        .color-input-group input[type="text"] {
            padding: 6px 8px;
            background: #3e3e42;
            border: 1px solid #555;
            border-radius: 3px;
            color: #ccc;
            font-size: 13px;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        .file-input-label {
            display: block;
            padding: 8px 16px;
            background: rgba(255,255,255,0.2);
            color: white;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .canvas-info {
            margin-bottom: 15px;
            padding: 10px;
            background: #3e3e42;
            border-radius: 4px;
            font-size: 12px;
        }
        .canvas-info div {
            margin-bottom: 5px;
        }
        .layers-list {
            max-height: 200px;
            overflow-y: auto;
            background: #3e3e42;
            border-radius: 4px;
            padding: 5px;
        }
        .layer-item {
            padding: 8px;
            margin-bottom: 3px;
            background: #2d2d30;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        .layer-item:hover {
            background: #3e3e42;
        }
        .layer-item.selected {
            background: #667eea;
            color: white;
        }
        .layer-item .delete-btn {
            background: #f56565;
            border: none;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        .no-selection {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 13px;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <span>ğŸ¨</span>
                <span>SVG å›¾å½¢ç¼–è¾‘å™¨</span>
            </h1>
            <div class="header-buttons">
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".svg,image/svg+xml">
                    <label for="fileInput" class="file-input-label">ğŸ“ æ‰“å¼€SVG</label>
                </div>
                <button onclick="downloadSVG()">ğŸ’¾ ä¸‹è½½SVG</button>
                <button onclick="downloadPNG()">ğŸ“· å¯¼å‡ºPNG</button>
                <button onclick="clearCanvas()">ğŸ—‘ï¸ æ¸…ç©ºç”»å¸ƒ</button>
            </div>
        </div>

        <div class="main-content">
            <!-- å·¥å…·æ  -->
            <div class="toolbar">
                <div class="tool-btn active" data-tool="select" onclick="selectTool('select')">
                    <div class="icon">â¤</div>
                    <div>é€‰æ‹©</div>
                </div>
                <div class="tool-btn" data-tool="rect" onclick="selectTool('rect')">
                    <div class="icon">â–­</div>
                    <div>çŸ©å½¢</div>
                </div>
                <div class="tool-btn" data-tool="circle" onclick="selectTool('circle')">
                    <div class="icon">â—‹</div>
                    <div>åœ†å½¢</div>
                </div>
                <div class="tool-btn" data-tool="ellipse" onclick="selectTool('ellipse')">
                    <div class="icon">â¬­</div>
                    <div>æ¤­åœ†</div>
                </div>
                <div class="tool-btn" data-tool="line" onclick="selectTool('line')">
                    <div class="icon">â•±</div>
                    <div>ç›´çº¿</div>
                </div>
                <div class="tool-btn" data-tool="text" onclick="selectTool('text')">
                    <div class="icon">T</div>
                    <div>æ–‡å­—</div>
                </div>
                <div class="tool-btn" data-tool="path" onclick="selectTool('path')">
                    <div class="icon">âœ</div>
                    <div>è·¯å¾„</div>
                </div>
                <div class="tool-btn" data-tool="polygon" onclick="selectTool('polygon')">
                    <div class="icon">â¬Ÿ</div>
                    <div>å¤šè¾¹å½¢</div>
                </div>
            </div>

            <!-- ç”»å¸ƒåŒºåŸŸ -->
            <div class="canvas-area">
                <svg id="svgCanvas" width="800" height="600" xmlns="http://www.w3.org/2000/svg">
                    <!-- ç½‘æ ¼èƒŒæ™¯ -->
                    <defs>
                        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                            <rect width="20" height="20" fill="white"/>
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#f0f0f0" stroke-width="0.5"/>
                        </pattern>
                    </defs>
                    <rect width="100%" height="100%" fill="url(#grid)" />
                </svg>
            </div>

            <!-- å±æ€§é¢æ¿ -->
            <div class="properties-panel">
                <div class="panel-section">
                    <h3>ğŸ“ ç”»å¸ƒè®¾ç½®</h3>
                    <div class="property-group">
                        <label>å®½åº¦ (px)</label>
                        <input type="number" id="canvasWidth" value="800" min="100" max="3000" onchange="updateCanvasSize()">
                    </div>
                    <div class="property-group">
                        <label>é«˜åº¦ (px)</label>
                        <input type="number" id="canvasHeight" value="600" min="100" max="3000" onchange="updateCanvasSize()">
                    </div>
                </div>

                <div id="elementProperties">
                    <div class="no-selection">
                        è¯·åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶æˆ–é€‰æ‹©å…ƒç´ 
                    </div>
                </div>

                <div class="panel-section">
                    <h3>ğŸ“š å›¾å±‚</h3>
                    <div class="layers-list" id="layersList">
                        <div class="no-selection">æš‚æ— å›¾å±‚</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentTool = 'select';
        let isDrawing = false;
        let startX, startY;
        let currentElement = null;
        let selectedElement = null;
        let elements = [];
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let pathPoints = [];
        let polygonPoints = [];

        const canvas = document.getElementById('svgCanvas');
        const ns = 'http://www.w3.org/2000/svg';

        // é»˜è®¤æ ·å¼
        const defaultStyle = {
            fill: '#667eea',
            stroke: '#764ba2',
            strokeWidth: 2,
            opacity: 1
        };

        // é€‰æ‹©å·¥å…·
        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

            // æ›´æ–°å…‰æ ‡
            if (tool === 'select') {
                canvas.style.cursor = 'default';
            } else if (tool === 'text') {
                canvas.style.cursor = 'text';
            } else {
                canvas.style.cursor = 'crosshair';
            }

            // æ¸…é™¤è·¯å¾„å’Œå¤šè¾¹å½¢çš„ä¸´æ—¶ç‚¹
            pathPoints = [];
            polygonPoints = [];
        }

        // è·å–é¼ æ ‡åœ¨SVGä¸­çš„åæ ‡
        function getMousePosition(evt) {
            const CTM = canvas.getScreenCTM();
            return {
                x: (evt.clientX - CTM.e) / CTM.a,
                y: (evt.clientY - CTM.f) / CTM.d
            };
        }

        // é¼ æ ‡æŒ‰ä¸‹
        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePosition(e);
            startX = pos.x;
            startY = pos.y;

            if (currentTool === 'select') {
                // é€‰æ‹©æ¨¡å¼
                const clickedElement = e.target;
                if (clickedElement !== canvas && clickedElement.tagName !== 'rect' || clickedElement.hasAttribute('data-element')) {
                    selectElement(clickedElement);
                    isDragging = true;
                    dragOffsetX = pos.x - parseFloat(clickedElement.getAttribute('x') || clickedElement.getAttribute('cx') || 0);
                    dragOffsetY = pos.y - parseFloat(clickedElement.getAttribute('y') || clickedElement.getAttribute('cy') || 0);
                } else {
                    deselectElement();
                }
            } else if (currentTool === 'text') {
                // æ–‡å­—å·¥å…·
                const text = prompt('è¯·è¾“å…¥æ–‡å­—ï¼š', 'Hello SVG');
                if (text) {
                    const textElement = document.createElementNS(ns, 'text');
                    textElement.setAttribute('x', pos.x);
                    textElement.setAttribute('y', pos.y);
                    textElement.setAttribute('fill', defaultStyle.fill);
                    textElement.setAttribute('font-size', '24');
                    textElement.setAttribute('font-family', 'Arial');
                    textElement.setAttribute('data-element', 'true');
                    textElement.textContent = text;
                    canvas.appendChild(textElement);
                    elements.push(textElement);
                    updateLayers();
                }
            } else if (currentTool === 'path') {
                // è·¯å¾„å·¥å…· - ç‚¹å‡»æ·»åŠ ç‚¹
                pathPoints.push({x: pos.x, y: pos.y});
                if (pathPoints.length === 1) {
                    currentElement = document.createElementNS(ns, 'path');
                    currentElement.setAttribute('fill', 'none');
                    currentElement.setAttribute('stroke', defaultStyle.stroke);
                    currentElement.setAttribute('stroke-width', defaultStyle.strokeWidth);
                    currentElement.setAttribute('data-element', 'true');
                    canvas.appendChild(currentElement);
                }
                updatePath();
            } else if (currentTool === 'polygon') {
                // å¤šè¾¹å½¢å·¥å…· - ç‚¹å‡»æ·»åŠ ç‚¹
                if (e.detail === 2) { // åŒå‡»å®Œæˆ
                    if (polygonPoints.length >= 3) {
                        finishPolygon();
                    }
                } else {
                    polygonPoints.push({x: pos.x, y: pos.y});
                    if (polygonPoints.length === 1) {
                        currentElement = document.createElementNS(ns, 'polygon');
                        currentElement.setAttribute('fill', defaultStyle.fill);
                        currentElement.setAttribute('stroke', defaultStyle.stroke);
                        currentElement.setAttribute('stroke-width', defaultStyle.strokeWidth);
                        currentElement.setAttribute('data-element', 'true');
                        canvas.appendChild(currentElement);
                    }
                    updatePolygon();
                }
            } else {
                // ç»˜å›¾æ¨¡å¼
                isDrawing = true;
                createShape(currentTool, pos);
            }
        });

        // é¼ æ ‡ç§»åŠ¨
        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePosition(e);

            if (isDragging && selectedElement) {
                // æ‹–åŠ¨å…ƒç´ 
                moveElement(selectedElement, pos.x - dragOffsetX, pos.y - dragOffsetY);
                updateProperties();
            } else if (isDrawing && currentElement) {
                // ç»˜åˆ¶å½¢çŠ¶
                updateShape(currentTool, pos);
            }
        });

        // é¼ æ ‡æŠ¬èµ·
        canvas.addEventListener('mouseup', () => {
            if (isDrawing && currentElement) {
                elements.push(currentElement);
                updateLayers();
            }
            isDrawing = false;
            isDragging = false;
            currentElement = null;
        });

        // åŒå‡»å®Œæˆè·¯å¾„ç»˜åˆ¶
        canvas.addEventListener('dblclick', (e) => {
            if (currentTool === 'path' && pathPoints.length >= 2) {
                elements.push(currentElement);
                updateLayers();
                pathPoints = [];
                currentElement = null;
            }
        });

        // åˆ›å»ºå½¢çŠ¶
        function createShape(tool, pos) {
            if (tool === 'rect') {
                currentElement = document.createElementNS(ns, 'rect');
                currentElement.setAttribute('x', pos.x);
                currentElement.setAttribute('y', pos.y);
                currentElement.setAttribute('fill', defaultStyle.fill);
                currentElement.setAttribute('stroke', defaultStyle.stroke);
                currentElement.setAttribute('stroke-width', defaultStyle.strokeWidth);
            } else if (tool === 'circle') {
                currentElement = document.createElementNS(ns, 'circle');
                currentElement.setAttribute('cx', pos.x);
                currentElement.setAttribute('cy', pos.y);
                currentElement.setAttribute('fill', defaultStyle.fill);
                currentElement.setAttribute('stroke', defaultStyle.stroke);
                currentElement.setAttribute('stroke-width', defaultStyle.strokeWidth);
            } else if (tool === 'ellipse') {
                currentElement = document.createElementNS(ns, 'ellipse');
                currentElement.setAttribute('cx', pos.x);
                currentElement.setAttribute('cy', pos.y);
                currentElement.setAttribute('fill', defaultStyle.fill);
                currentElement.setAttribute('stroke', defaultStyle.stroke);
                currentElement.setAttribute('stroke-width', defaultStyle.strokeWidth);
            } else if (tool === 'line') {
                currentElement = document.createElementNS(ns, 'line');
                currentElement.setAttribute('x1', pos.x);
                currentElement.setAttribute('y1', pos.y);
                currentElement.setAttribute('x2', pos.x);
                currentElement.setAttribute('y2', pos.y);
                currentElement.setAttribute('stroke', defaultStyle.stroke);
                currentElement.setAttribute('stroke-width', defaultStyle.strokeWidth);
            }

            if (currentElement) {
                currentElement.setAttribute('data-element', 'true');
                canvas.appendChild(currentElement);
            }
        }

        // æ›´æ–°å½¢çŠ¶
        function updateShape(tool, pos) {
            if (!currentElement) return;

            if (tool === 'rect') {
                const width = Math.abs(pos.x - startX);
                const height = Math.abs(pos.y - startY);
                const x = Math.min(pos.x, startX);
                const y = Math.min(pos.y, startY);
                currentElement.setAttribute('x', x);
                currentElement.setAttribute('y', y);
                currentElement.setAttribute('width', width);
                currentElement.setAttribute('height', height);
            } else if (tool === 'circle') {
                const radius = Math.sqrt(Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2));
                currentElement.setAttribute('r', radius);
            } else if (tool === 'ellipse') {
                const rx = Math.abs(pos.x - startX);
                const ry = Math.abs(pos.y - startY);
                currentElement.setAttribute('rx', rx);
                currentElement.setAttribute('ry', ry);
            } else if (tool === 'line') {
                currentElement.setAttribute('x2', pos.x);
                currentElement.setAttribute('y2', pos.y);
            }
        }

        // æ›´æ–°è·¯å¾„
        function updatePath() {
            if (!currentElement || pathPoints.length === 0) return;
            let d = `M ${pathPoints[0].x} ${pathPoints[0].y}`;
            for (let i = 1; i < pathPoints.length; i++) {
                d += ` L ${pathPoints[i].x} ${pathPoints[i].y}`;
            }
            currentElement.setAttribute('d', d);
        }

        // æ›´æ–°å¤šè¾¹å½¢
        function updatePolygon() {
            if (!currentElement || polygonPoints.length === 0) return;
            const points = polygonPoints.map(p => `${p.x},${p.y}`).join(' ');
            currentElement.setAttribute('points', points);
        }

        // å®Œæˆå¤šè¾¹å½¢
        function finishPolygon() {
            if (currentElement) {
                elements.push(currentElement);
                updateLayers();
            }
            polygonPoints = [];
            currentElement = null;
        }

        // ç§»åŠ¨å…ƒç´ 
        function moveElement(element, x, y) {
            const tagName = element.tagName;
            if (tagName === 'rect' || tagName === 'text' || tagName === 'image') {
                element.setAttribute('x', x);
                element.setAttribute('y', y);
            } else if (tagName === 'circle' || tagName === 'ellipse') {
                element.setAttribute('cx', x);
                element.setAttribute('cy', y);
            } else if (tagName === 'line') {
                const dx = x - parseFloat(element.getAttribute('x1'));
                const dy = y - parseFloat(element.getAttribute('y1'));
                element.setAttribute('x1', x);
                element.setAttribute('y1', y);
                element.setAttribute('x2', parseFloat(element.getAttribute('x2')) + dx);
                element.setAttribute('y2', parseFloat(element.getAttribute('y2')) + dy);
            }
        }

        // é€‰æ‹©å…ƒç´ 
        function selectElement(element) {
            deselectElement();
            selectedElement = element;
            element.style.outline = '2px dashed #667eea';
            element.style.outlineOffset = '2px';
            updateProperties();
            highlightLayer(element);
        }

        // å–æ¶ˆé€‰æ‹©
        function deselectElement() {
            if (selectedElement) {
                selectedElement.style.outline = '';
                selectedElement = null;
            }
            updateProperties();
        }

        // æ›´æ–°å±æ€§é¢æ¿
        function updateProperties() {
            const panel = document.getElementById('elementProperties');

            if (!selectedElement) {
                panel.innerHTML = '<div class="no-selection">è¯·åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶æˆ–é€‰æ‹©å…ƒç´ </div>';
                return;
            }

            const tagName = selectedElement.tagName;
            let html = '<div class="panel-section"><h3>âœï¸ å…ƒç´ å±æ€§</h3>';

            html += `<div class="property-group">
                <label>å…ƒç´ ç±»å‹</label>
                <input type="text" value="${tagName}" disabled>
            </div>`;

            // å¡«å……é¢œè‰²
            if (tagName !== 'line') {
                const fill = selectedElement.getAttribute('fill') || '#667eea';
                html += `<div class="property-group">
                    <label>å¡«å……é¢œè‰²</label>
                    <div class="color-input-group">
                        <input type="color" value="${fill}" onchange="updateElementProp('fill', this.value)">
                        <input type="text" value="${fill}" onchange="updateElementProp('fill', this.value)">
                    </div>
                </div>`;
            }

            // è¾¹æ¡†é¢œè‰²
            const stroke = selectedElement.getAttribute('stroke') || '#764ba2';
            html += `<div class="property-group">
                <label>è¾¹æ¡†é¢œè‰²</label>
                <div class="color-input-group">
                    <input type="color" value="${stroke}" onchange="updateElementProp('stroke', this.value)">
                    <input type="text" value="${stroke}" onchange="updateElementProp('stroke', this.value)">
                </div>
            </div>`;

            // è¾¹æ¡†å®½åº¦
            const strokeWidth = selectedElement.getAttribute('stroke-width') || '2';
            html += `<div class="property-group">
                <label>è¾¹æ¡†å®½åº¦</label>
                <input type="number" value="${strokeWidth}" min="0" max="20" onchange="updateElementProp('stroke-width', this.value)">
            </div>`;

            // ç‰¹å®šå±æ€§
            if (tagName === 'rect') {
                html += `
                    <div class="property-group">
                        <label>X åæ ‡</label>
                        <input type="number" value="${selectedElement.getAttribute('x')}" onchange="updateElementProp('x', this.value)">
                    </div>
                    <div class="property-group">
                        <label>Y åæ ‡</label>
                        <input type="number" value="${selectedElement.getAttribute('y')}" onchange="updateElementProp('y', this.value)">
                    </div>
                    <div class="property-group">
                        <label>å®½åº¦</label>
                        <input type="number" value="${selectedElement.getAttribute('width')}" onchange="updateElementProp('width', this.value)">
                    </div>
                    <div class="property-group">
                        <label>é«˜åº¦</label>
                        <input type="number" value="${selectedElement.getAttribute('height')}" onchange="updateElementProp('height', this.value)">
                    </div>
                `;
            } else if (tagName === 'circle') {
                html += `
                    <div class="property-group">
                        <label>ä¸­å¿ƒ X</label>
                        <input type="number" value="${selectedElement.getAttribute('cx')}" onchange="updateElementProp('cx', this.value)">
                    </div>
                    <div class="property-group">
                        <label>ä¸­å¿ƒ Y</label>
                        <input type="number" value="${selectedElement.getAttribute('cy')}" onchange="updateElementProp('cy', this.value)">
                    </div>
                    <div class="property-group">
                        <label>åŠå¾„</label>
                        <input type="number" value="${selectedElement.getAttribute('r')}" onchange="updateElementProp('r', this.value)">
                    </div>
                `;
            } else if (tagName === 'text') {
                html += `
                    <div class="property-group">
                        <label>æ–‡å­—å†…å®¹</label>
                        <input type="text" value="${selectedElement.textContent}" onchange="updateElementText(this.value)">
                    </div>
                    <div class="property-group">
                        <label>å­—ä½“å¤§å°</label>
                        <input type="number" value="${selectedElement.getAttribute('font-size') || 24}" onchange="updateElementProp('font-size', this.value)">
                    </div>
                `;
            }

            html += '</div>';
            panel.innerHTML = html;
        }

        // æ›´æ–°å…ƒç´ å±æ€§
        function updateElementProp(attr, value) {
            if (selectedElement) {
                selectedElement.setAttribute(attr, value);
            }
        }

        // æ›´æ–°æ–‡å­—å†…å®¹
        function updateElementText(value) {
            if (selectedElement && selectedElement.tagName === 'text') {
                selectedElement.textContent = value;
            }
        }

        // æ›´æ–°å›¾å±‚åˆ—è¡¨
        function updateLayers() {
            const layersList = document.getElementById('layersList');
            if (elements.length === 0) {
                layersList.innerHTML = '<div class="no-selection">æš‚æ— å›¾å±‚</div>';
                return;
            }

            let html = '';
            elements.forEach((el, index) => {
                const tagName = el.tagName;
                const isSelected = el === selectedElement ? 'selected' : '';
                html += `
                    <div class="layer-item ${isSelected}" onclick="selectElementByIndex(${index})">
                        <span>${tagName} ${index + 1}</span>
                        <button class="delete-btn" onclick="deleteElement(${index}, event)">åˆ é™¤</button>
                    </div>
                `;
            });
            layersList.innerHTML = html;
        }

        // é€šè¿‡ç´¢å¼•é€‰æ‹©å…ƒç´ 
        function selectElementByIndex(index) {
            if (elements[index]) {
                selectElement(elements[index]);
            }
        }

        // é«˜äº®å›¾å±‚
        function highlightLayer(element) {
            updateLayers();
        }

        // åˆ é™¤å…ƒç´ 
        function deleteElement(index, event) {
            event.stopPropagation();
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå…ƒç´ å—ï¼Ÿ')) {
                const element = elements[index];
                canvas.removeChild(element);
                elements.splice(index, 1);
                if (selectedElement === element) {
                    deselectElement();
                }
                updateLayers();
            }
        }

        // æ›´æ–°ç”»å¸ƒå¤§å°
        function updateCanvasSize() {
            const width = document.getElementById('canvasWidth').value;
            const height = document.getElementById('canvasHeight').value;
            canvas.setAttribute('width', width);
            canvas.setAttribute('height', height);
        }

        // ä¸Šä¼ SVGæ–‡ä»¶
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(e.target.result, 'image/svg+xml');
                const svgElement = doc.documentElement;

                // æ¸…ç©ºå½“å‰ç”»å¸ƒ
                while (canvas.childNodes.length > 1) {
                    canvas.removeChild(canvas.lastChild);
                }
                elements = [];

                // å¯¼å…¥SVGå…ƒç´ 
                Array.from(svgElement.children).forEach(child => {
                    if (child.tagName !== 'defs' && child.tagName !== 'pattern') {
                        const imported = document.importNode(child, true);
                        imported.setAttribute('data-element', 'true');
                        canvas.appendChild(imported);
                        elements.push(imported);
                    }
                });

                // æ›´æ–°ç”»å¸ƒå¤§å°
                if (svgElement.hasAttribute('width')) {
                    document.getElementById('canvasWidth').value = svgElement.getAttribute('width');
                }
                if (svgElement.hasAttribute('height')) {
                    document.getElementById('canvasHeight').value = svgElement.getAttribute('height');
                }
                updateCanvasSize();
                updateLayers();
            };
            reader.readAsText(file);
        });

        // ä¸‹è½½SVG
        function downloadSVG() {
            const svgData = new XMLSerializer().serializeToString(canvas);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'drawing_' + new Date().getTime() + '.svg';
            link.click();
            URL.revokeObjectURL(url);
        }

        // å¯¼å‡ºPNG
        function downloadPNG() {
            const svgData = new XMLSerializer().serializeToString(canvas);
            const img = new Image();
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);

            img.onload = () => {
                const canvasEl = document.createElement('canvas');
                canvasEl.width = canvas.width.baseVal.value;
                canvasEl.height = canvas.height.baseVal.value;
                const ctx = canvasEl.getContext('2d');
                ctx.drawImage(img, 0, 0);

                canvasEl.toBlob((blob) => {
                    const pngUrl = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = pngUrl;
                    link.download = 'drawing_' + new Date().getTime() + '.png';
                    link.click();
                    URL.revokeObjectURL(pngUrl);
                    URL.revokeObjectURL(url);
                });
            };

            img.src = url;
        }

        // æ¸…ç©ºç”»å¸ƒ
        function clearCanvas() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºç”»å¸ƒå—ï¼Ÿæ‰€æœ‰å…ƒç´ éƒ½å°†è¢«åˆ é™¤ï¼')) {
                while (canvas.childNodes.length > 1) {
                    canvas.removeChild(canvas.lastChild);
                }
                elements = [];
                deselectElement();
                updateLayers();
            }
        }
    </script>
</body>
</html>
